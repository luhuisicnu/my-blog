我们知道，Python2.X版本的字符串有两种：字符串和Unicode字符串。因为这两种字符串类型，导致无数的本地化应用出现字符串类型的错误。而现在，Python3.0的字符串全部采纳Unicode方案，并强化了b类型字符序列概念，并将字符序列和字符串进行了区分，不能执行`+`操作。

## 本地化编程
这个变化不但解决了长久以来的字符串兼容问题，而且让我们在编程过程中可以使用非英文字符作为变量名，如下：
```
In [1]: 打印函数 = print

In [2]: def 测试函数(变量):  # 注意，函数的括号必须是半角的，也就是英文输入法下的括号
   ...:     打印函数(变量)
   ...:     

In [3]: 名字 = 'Python3要翻天'  # 空格、等号和引号也必须用半角的

In [4]: 测试函数(名字)
Python3要翻天
```

虽然在实际编程中，大部分情况下都使用英文作为变量名，但是不排除在教育行业以及本地化项目中使用这种编程风格。

## 类型区别
虽然全面使用了unicode字符串，但是在Python解释器中，其类型的名称已经改成了`str`，以表示其普遍性。
字符串和字符序列的类型区别如下：
```
In [10]: a = '1'

In [11]: a.__class__
Out[11]: str

In [12]: b = b'1'

In [13]: b.__class__
Out[13]: bytes

In [14]: a + b
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-22-f96fb8f649b6> in <module>()
----> 1 a + b

TypeError: Can't convert 'bytes' object to str implicitly

```

## 使用区别
字符串和字符序列被区分成文本和数据，因此，在程序内部交互中，使用字符串更加方便，一旦需要进行IO交互，则可能会使用到字符序列了。不过，大部分接口支持接受字符串作为输入，并自动将其编码为默认编码的字符序列。
示例如下：
```
In [15]: sys.getdefaultencoding()  # 获取平台的默认编码
Out[15]: 'utf-8'

In [16]: with open('test.file', 'w') as f:   ## 默认编码为平台的默认编码
   ....:     f.write('测试文本')
   ....:     

In [17]: with open('test.file', 'wb') as f:  ## 直接写入字符序列，不用理会编码问题
   ....:     f.write('测试文本'.encode('utf-8'))
   ....:   
```

